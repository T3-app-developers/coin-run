<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Green-Head Coin Run</title>
<style>
  html, body { margin:0; padding:0; background:#21252b; color:#eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  #ui { position:fixed; inset:0 0 auto 0; display:flex; gap:16px; align-items:center; padding:10px 14px; font-weight:600; backdrop-filter: blur(4px);  }
  .pill { background:#2b2f36; border:1px solid #3a3f47; padding:6px 10px; border-radius:999px; box-shadow: inset 0 0 0 1px #00000040; }
  .good { color:#9ef79a; }
  .warn { color:#ff9e64; }
  .bad { color:#ff6b6b; }
  #help { position:fixed; right:10px; top:10px; background:#2b2f36; border:1px solid #3a3f47; padding:10px 12px; border-radius:10px; max-width: 420px; line-height:1.2; font-size:14px; }
  #overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:#000a; color:#fff; text-align:center; }
  #overlay .card { background:#1f232a; border:1px solid #3a3f47; border-radius:14px; padding:22px 24px; max-width:560px; }
  #overlay h1 { margin:0 0 8px 0; font-size:28px; }
  #overlay p { margin:6px 0; }
  canvas { display:block; width:100vw; height:100vh; image-rendering: pixelated; }
</style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>

<div id="ui">
  <div class="pill">P1 Coins: <span id="p1-coins" class="good">0</span></div>
  <div class="pill">P1 Wood: <span id="p1-wood" class="warn">0</span></div>
  <div class="pill">P1 Lives: <span id="p1-lives" class="good">3</span></div>
  <div class="pill">P2 Coins: <span id="p2-coins" class="good">0</span></div>
  <div class="pill">P2 Wood: <span id="p2-wood" class="warn">0</span></div>
  <div class="pill">P2 Lives: <span id="p2-lives" class="good">3</span></div>
  <div class="pill">Timer: <span id="timer" class="good">0:00.0</span></div>
  <div class="pill">Lava: <span id="lava" class="bad">hurts</span></div>
  <div class="pill">Goal ▶</div>
</div>

<div id="help">
  <b>Controls</b><br>
  <b>Player 1</b> – Move: <b>A/D</b> · Jump: <b>W</b>/<b>Space</b> · Mine: <b>E</b> (hold) · Wall: <b>1</b> · Lava: <b>2</b><br>
  <b>Player 2</b> – Move: <b>←/→</b> · Jump: <b>↑</b> · Mine: <b>/</b> (hold) · Wall: <b>[</b> · Lava: <b>]</b><br>
  Restart: <b>R</b> &nbsp;|&nbsp; Toggle Hitboxes: <b>H</b>
</div>

<div id="overlay">
  <div class="card">
    <h1 id="ov-title">Finished!</h1>
    <p id="ov-body"></p>
    <p style="opacity:0.8">Press <b>R</b> to play again.</p>
  </div>
</div>

<script>
(() => {
  // ===== helpers =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => Math.random() * (b - a) + a;
  const irand = (a, b) => Math.floor(rand(a, b));
  const sign = (x) => x < 0 ? -1 : 1;
  const formatTime = (sec) => {
    const totalTenths = Math.round(sec * 10);
    const minutes = Math.floor(totalTenths / 600);
    const seconds = Math.floor((totalTenths % 600) / 10);
    const tenths = totalTenths % 10;
    return `${minutes}:${seconds.toString().padStart(2,'0')}.${tenths}`;
  };

  // ===== canvas & sizing =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;

  function resize() {
    // Keep fixed internal resolution; CSS scales it.
    // (Could add DPR scaling if you prefer sharper rendering.)
  }
  window.addEventListener('resize', resize);

  // ===== UI elements =====
  const ui = {
    p1: {
      coins: document.getElementById('p1-coins'),
      wood: document.getElementById('p1-wood'),
      lives: document.getElementById('p1-lives'),
    },
    p2: {
      coins: document.getElementById('p2-coins'),
      wood: document.getElementById('p2-wood'),
      lives: document.getElementById('p2-lives'),
    }
  };
  const uiTimer = document.getElementById('timer');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ov-title');
  const ovBody  = document.getElementById('ov-body');

  // ===== world constants =====
  const TILE = 40;
  const GROUND_Y = 440;
  const LEVEL_LEN = 3000; // world ends here; goal near end
  const GOAL_X = LEVEL_LEN - 140;
  const GROUND_SURFACE = 16;
  const LAVA_RIM = 6;
  const LAVA_DEPTH = 28;
  const LAVA_HEIGHT = 14;
  const LAVA_SURFACE_Y = GROUND_Y + LAVA_DEPTH - LAVA_HEIGHT;

  // physics
  const GRAV = 0.9;
  const FRICTION = 0.85;
  const AIRFRIC = 0.98;
  const MOVE_ACCEL = 0.9;
  const MAX_RUN = 6.2;
  const JUMP_VEL = -16;

  // game state
  let keys = {};
  let debugShowHit = false;
  let finished = false;
  let runStartTime = 0;
  let elapsedTime = 0;
  let finishDuration = 0;

  // ===== entities =====
  class Player {
    constructor(x, y, options = {}) {
      this.x = x; this.y = y;
      this.vx = 0; this.vy = 0;
      this.w = 22; this.h = 34; // compact body; head drawn on top
      this.grounded = false;
      this.facing = 1; // 1 right, -1 left
      this.safeX = x; this.safeY = y;
      this.coins = 0;
      this.wood = 0;
      this.invuln = 0; // frames
      this.lives = 3;
      this.deaths = 0;
      this.finished = false;
      this.label = options.label || 'P';
      this.bodyColor = options.bodyColor || '#2f3b52';
      this.headColor = options.headColor || '#2fd06c';
      this.controls = options.controls || {};
    }
    aabb() { return {x:this.x, y:this.y, w:this.w, h:this.h}; }
    centerX() { return this.x + this.w/2; }
    bottom() { return this.y + this.h; }
    controlDown(action) {
      const binds = this.controls[action];
      if (!binds) return false;
      return binds.some(k => !!keys[k]);
    }
  }

  class Tree {
    constructor(x) {
      this.x = x;
      this.w = 30;
      this.h = 100;
      this.baseY = GROUND_Y - this.h;
      this.hp = 3; // number of "chunks"
      this.progress = 0; // chopping progress per segment
      this.dead = false;
    }
    aabb() { return {x:this.x, y:this.baseY, w:this.w, h:this.h}; }
  }

  class Wall {
    constructor(x, y) {
      this.x = x; this.y = y; // top-left
      this.w = TILE; this.h = TILE;
    }
    aabb() { return {x:this.x, y:this.y, w:this.w, h:this.h}; }
  }

  class Lava {
    constructor(x) {
      this.x = x;
      this.y = LAVA_SURFACE_Y;
      this.w = TILE;
      this.h = LAVA_HEIGHT;
      this.phase = rand(0, 1000);
    }
    aabb() { return {x:this.x, y:this.y, w:this.w, h:this.h}; }
  }

  class Coin {
    constructor(x, y) {
      this.x = x; this.y = y;
      this.r = 10;
      this.t = 0;
      this.collected = false;
    }
  }

  // ===== world containers =====
  let players = [];
  let trees = [];
  let walls = [];
  let lavas = [];
  let coins = [];

  // ===== camera =====
  let camX = 0;

  function resetLevel() {
    finished = false;
    overlay.style.display = 'none';
    trees = []; walls = []; lavas = []; coins = [];
    players = [
      new Player(100, GROUND_Y - 34, {
        label: 'P1',
        headColor: '#2fd06c',
        bodyColor: '#2f3b52',
        controls: {
          left: ['a','A'],
          right: ['d','D'],
          jump: ['w','W',' '],
          chop: ['e','E'],
          wall: ['1'],
          lava: ['2'],
        }
      }),
      new Player(160, GROUND_Y - 34, {
        label: 'P2',
        headColor: '#3fb5ff',
        bodyColor: '#233149',
        controls: {
          left: ['ArrowLeft'],
          right: ['ArrowRight'],
          jump: ['ArrowUp'],
          chop: ['/', '?'],
          wall: ['[', '{'],
          lava: [']', '}'],
        }
      })
    ];
    // scatter trees
    const bands = 22;
    for (let i=0; i<bands; i++) {
      const x = irand(160 + i * ((LEVEL_LEN-400)/bands), 180 + i * ((LEVEL_LEN-400)/bands));
      trees.push(new Tree(x));
    }
    // sprinkle a few natural hazards
    for (let i=0; i<6; i++) {
      const x = irand(260, LEVEL_LEN - 400);
      lavas.push(new Lava(tileX(x)));
    }
    camX = 0;
    runStartTime = performance.now();
    elapsedTime = 0;
    finishDuration = 0;
    keys = {};
    updateUI();
    uiTimer.textContent = formatTime(0);
  }

  // ===== controls =====
  window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (e.key === 'r' || e.key === 'R') { resetLevel(); return; }
    if (e.key === 'h' || e.key === 'H') debugShowHit = !debugShowHit;

    if (finished) return;

    for (const player of players) {
      if (player.finished) continue;
      if (player.controls.wall && player.controls.wall.includes(e.key)) placeWall(player);
      if (player.controls.lava && player.controls.lava.includes(e.key)) placeLava(player);
    }
  });
  window.addEventListener('keyup', (e) => { keys[e.key] = false; });

  // ===== placement helpers =====
  function tileX(x) { return Math.floor(x / TILE) * TILE; }

  function spaceFreeForWall(tx, ty) {
    // no overlap with existing walls or trees; must sit on ground
    if (ty !== GROUND_Y - TILE) return false;
    const rect = {x:tx, y:ty, w:TILE, h:TILE};
    if (walls.some(w => aabbOverlap(rect, w.aabb()))) return false;
    if (trees.some(t => aabbOverlap(rect, t.aabb()))) return false;
    return true;
  }

  function spaceFreeForLava(tx, ty) {
    if (ty !== LAVA_SURFACE_Y) return false;
    const rect = {x:tx, y:ty, w:TILE, h:LAVA_HEIGHT};
    if (lavas.some(l => aabbOverlap(rect, l.aabb()))) return false;
    if (walls.some(w => tx < w.x + w.w && tx + TILE > w.x)) return false;
    if (trees.some(t => !t.dead && tx < t.x + t.w && tx + TILE > t.x)) return false;
    return true;
  }

  function placeWall(player) {
    if (player.wood <= 0) return;
    const ahead = player.centerX() + player.facing * (TILE * 1.2);
    const tx = tileX(ahead);
    const ty = GROUND_Y - TILE;
    if (!spaceFreeForWall(tx, ty)) return;
    walls.push(new Wall(tx, ty));
    // spawn coin on top
    coins.push(new Coin(tx + TILE/2, ty - 18));
    player.wood -= 1;
    updateUI();
  }

  function placeLava(player) {
    if (player.wood <= 0) return;
    const ahead = player.centerX() + player.facing * (TILE * 1.2);
    const tx = tileX(ahead);
    const ty = LAVA_SURFACE_Y;
    if (!spaceFreeForLava(tx, ty)) return;
    lavas.push(new Lava(tx));
    player.wood -= 1;
    updateUI();
  }

  // ===== collisions =====
  function aabbOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function handlePlayerDeath(player) {
    player.lives -= 1;
    player.deaths += 1;
    if (player.lives <= 0) {
      resetLevel();
      return true;
    }
    if (player.coins > 0) player.coins -= 1;
    player.x = Math.max(0, player.safeX - 60);
    player.y = player.safeY;
    player.vx = 0;
    player.vy = 0;
    player.invuln = 30;
    updateUI();
    return false;
  }

  // ===== game loop =====
  let last = performance.now();
  function loop(t) {
    const dt = Math.min(33, t - last) / 16.666; // normalize to 60fps steps
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    const now = performance.now();
    if (!finished) {
      elapsedTime = (now - runStartTime) / 1000;
      uiTimer.textContent = formatTime(elapsedTime);
    }

    for (const player of players) {
      // controls
      if (!finished && !player.finished) {
        let ax = 0;
        if (player.controlDown('left')) { ax -= MOVE_ACCEL; player.facing = -1; }
        if (player.controlDown('right')) { ax += MOVE_ACCEL; player.facing =  1; }
        player.vx += ax * dt;

        const onGround = player.grounded;
        if (player.controlDown('jump') && onGround) {
          player.vy = JUMP_VEL;
          player.grounded = false;
        }
      }

      // physics integrate
      player.vy += GRAV * dt;
      if (player.grounded) player.vx *= Math.pow(FRICTION, dt);
      else player.vx *= Math.pow(AIRFRIC, dt);
      player.vx = clamp(player.vx, -MAX_RUN, MAX_RUN);

      // move horizontal
      player.x += player.vx * dt;
      for (const w of walls) {
        const a = player.aabb(), b = w.aabb();
        if (aabbOverlap(a,b)) {
          if (player.vx > 0) player.x = b.x - player.w;
          if (player.vx < 0) player.x = b.x + b.w;
          player.vx = 0;
        }
      }
      player.x = clamp(player.x, 0, LEVEL_LEN - player.w);

      // move vertical
      player.y += player.vy * dt;
      player.grounded = false;

      const feetRect = {x: player.x + 2, y: player.bottom() - 4, w: player.w - 4, h: 6};
      const overLava = lavas.some(l => feetRect.x < l.x + l.w && feetRect.x + feetRect.w > l.x);

      if (player.bottom() >= GROUND_Y && !overLava) {
        player.y = GROUND_Y - player.h;
        player.vy = 0;
        player.grounded = true;
        player.safeX = player.x;
        player.safeY = player.y;
      }
      for (const w of walls) {
        const a = player.aabb(), b = w.aabb();
        if (aabbOverlap(a,b)) {
          if (player.vy > 0) {
            player.y = b.y - player.h;
            player.vy = 0;
            player.grounded = true;
          } else if (player.vy < 0) {
            player.y = b.y + b.h;
            player.vy = 0.1;
          }
        }
      }

      if (player.invuln > 0) player.invuln -= dt;
      for (const l of lavas) {
        if (aabbOverlap(player.aabb(), l.aabb()) && player.invuln <= 0) {
          if (handlePlayerDeath(player)) return;
        }
      }
    }

    // mine tree (hold)
    if (!finished) {
      for (const tr of trees) {
        if (tr.dead) continue;
        let worked = false;
        for (const player of players) {
          if (player.finished) continue;
          if (!player.controlDown('chop')) continue;
          const near = Math.abs((tr.x + tr.w/2) - player.centerX()) < 38 && Math.abs((tr.baseY + tr.h) - player.bottom()) < 50;
          if (near) {
            worked = true;
            tr.progress += 0.04 * dt;
            if (tr.progress >= 1) {
              tr.progress = 0;
              tr.hp -= 1;
              if (tr.hp <= 0) {
                tr.dead = true;
                player.wood += 2;
                updateUI();
              }
            }
          }
        }
        if (!worked) tr.progress = Math.max(0, tr.progress - 0.02 * dt);
      }
    } else {
      for (const tr of trees) {
        tr.progress = Math.max(0, tr.progress - 0.02 * dt);
      }
    }

    // coin pickup
    for (const c of coins) {
      if (!c.collected) {
        for (const player of players) {
          const dx = player.centerX() - c.x;
          const dy = (player.y + player.h/2) - c.y;
          if (dx*dx + dy*dy < (14*14)) {
            c.collected = true;
            player.coins += 1;
            updateUI();
            break;
          }
        }
      }
      c.t += 0.05 * dt;
    }

    // camera
    if (players.length) {
      const avgX = players.reduce((sum, p) => sum + p.centerX(), 0) / players.length;
      camX += ((avgX - W * 0.45) - camX) * 0.08;
      camX = clamp(camX, 0, LEVEL_LEN - W);
    }

    // finish check
    if (!finished && players.length) {
      for (const player of players) {
        if (!player.finished && player.x > GOAL_X) {
          player.finished = true;
          player.vx = 0;
          player.vy = 0;
          player.grounded = true;
        }
      }
      if (players.every(p => p.finished)) {
        finished = true;
        finishDuration = elapsedTime;
        const summary = players.map(p => `${p.label}: Coins <b>${p.coins}</b> · Wood <b>${p.wood}</b> · Deaths <b>${p.deaths}</b>`).join('<br>');
        ovTitle.textContent = "Run Complete!";
        ovBody.innerHTML = `Finished in <b>${formatTime(finishDuration)}</b>.<br>${summary}`;
        overlay.style.display = 'flex';
        uiTimer.textContent = formatTime(finishDuration);
      }
    }
  }

  function updateUI() {
    const [p1, p2] = players;
    if (p1) {
      ui.p1.coins.textContent = p1.coins;
      ui.p1.wood.textContent = p1.wood;
      ui.p1.lives.textContent = p1.lives;
    } else {
      ui.p1.coins.textContent = '0';
      ui.p1.wood.textContent = '0';
      ui.p1.lives.textContent = '0';
    }
    if (p2) {
      ui.p2.coins.textContent = p2.coins;
      ui.p2.wood.textContent = p2.wood;
      ui.p2.lives.textContent = p2.lives;
    } else {
      ui.p2.coins.textContent = '0';
      ui.p2.wood.textContent = '0';
      ui.p2.lives.textContent = '0';
    }
  }

  // ===== drawing =====
  function drawGround() {
    // sky
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0,'#6ec6ff');
    grd.addColorStop(1,'#bfeaff');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);

    // far hills
    ctx.save();
    ctx.translate(-camX*0.3,0);
    ctx.fillStyle = '#9ed39b';
    for (let i=0;i<8;i++){
      const x = i*500;
      ctx.beginPath();
      ctx.moveTo(x, 380);
      ctx.quadraticCurveTo(x+120,330,x+240,380);
      ctx.quadraticCurveTo(x+360,330,x+480,380);
      ctx.lineTo(x+480,H);
      ctx.lineTo(x,H);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // ground band
    ctx.save();
    ctx.translate(-camX,0);
    const turfTop = GROUND_Y - GROUND_SURFACE;
    const turfGrad = ctx.createLinearGradient(0, turfTop, 0, GROUND_Y + 4);
    turfGrad.addColorStop(0, '#90e084');
    turfGrad.addColorStop(0.45, '#66ba5d');
    turfGrad.addColorStop(1, '#447d3d');
    ctx.fillStyle = turfGrad;
    ctx.fillRect(0, turfTop, LEVEL_LEN, GROUND_SURFACE + 4);
    ctx.fillStyle = '#2f4f2d';
    ctx.fillRect(0, GROUND_Y - 2, LEVEL_LEN, 2);
    ctx.fillStyle = '#0003';
    ctx.fillRect(0, GROUND_Y, LEVEL_LEN, 2);

    const frontGrad = ctx.createLinearGradient(0, GROUND_Y, 0, H);
    frontGrad.addColorStop(0, '#4b3a25');
    frontGrad.addColorStop(0.5, '#3a2718');
    frontGrad.addColorStop(1, '#1f140b');
    ctx.fillStyle = frontGrad;
    ctx.fillRect(0, GROUND_Y, LEVEL_LEN, H-GROUND_Y);

    // subtle stratified dirt lines
    ctx.fillStyle = '#0002';
    for (let y = GROUND_Y + 18; y < H; y += 26) {
      ctx.fillRect(0, y, LEVEL_LEN, 4);
    }

    // grass blades
    ctx.strokeStyle = '#9ef79a';
    ctx.lineWidth = 1;
    for (let x=0; x<LEVEL_LEN; x+=8) {
      const gx = x + Math.sin((x+performance.now()*0.002)*0.1)*1.2;
      ctx.beginPath();
      ctx.moveTo(gx, turfTop);
      ctx.lineTo(gx, turfTop - (x%16<8?5:7));
      ctx.stroke();
    }
    // goal flag
    ctx.fillStyle = '#333';
    ctx.fillRect(GOAL_X, GROUND_Y-60, 4, 60);
    ctx.fillStyle = '#ffd166';
    ctx.beginPath();
    ctx.moveTo(GOAL_X+4, GROUND_Y-56);
    ctx.lineTo(GOAL_X+54, GROUND_Y-46);
    ctx.lineTo(GOAL_X+4, GROUND_Y-36);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawTree(tr) {
    if (tr.dead) return;
    ctx.save();
    ctx.translate(-camX,0);
    // trunk
    ctx.fillStyle = '#7c4f2a';
    ctx.fillRect(tr.x + 10, tr.baseY + 30, 10, tr.h - 30);
    // canopy
    ctx.fillStyle = '#3a7d3a';
    ctx.beginPath();
    ctx.roundRect(tr.x, tr.baseY, tr.w, 40, 10);
    ctx.fill();
    ctx.beginPath();
    ctx.roundRect(tr.x-6, tr.baseY+18, tr.w+12, 34, 12);
    ctx.fill();

    // chop progress bar if nearby / active
    const near = players.some(p => Math.abs((tr.x + tr.w/2) - p.centerX()) < 38 && Math.abs((tr.baseY + tr.h) - p.bottom()) < 50);
    if (near && !finished) {
      ctx.fillStyle = '#0008';
      ctx.fillRect(tr.x-6, tr.baseY-16, tr.w+12, 8);
      ctx.fillStyle = '#9ef79a';
      ctx.fillRect(tr.x-6, tr.baseY-16, (tr.w+12) * (tr.progress), 8);
      // HP pips
      ctx.fillStyle = '#ffd166';
      for (let i=0;i<tr.hp;i++){
        ctx.fillRect(tr.x + 4 + i*8, tr.baseY-28, 6, 6);
      }
    }

    if (debugShowHit) {
      const a=tr.aabb();
      ctx.strokeStyle='#fff8'; ctx.strokeRect(a.x, a.y, a.w, a.h);
    }
    ctx.restore();
  }

  function drawWall(w) {
    ctx.save(); ctx.translate(-camX,0);
    // block
    ctx.fillStyle = '#9399a3';
    ctx.fillRect(w.x, w.y, w.w, w.h);
    // fake brick lines
    ctx.strokeStyle = '#747b85';
    ctx.lineWidth = 1;
    for (let y=0; y<w.h; y+=10) {
      ctx.beginPath(); ctx.moveTo(w.x, w.y+y); ctx.lineTo(w.x+w.w, w.y+y); ctx.stroke();
    }
    ctx.restore();
    if (debugShowHit) {
      const a=w.aabb();
      ctx.save(); ctx.translate(-camX,0); ctx.strokeStyle='#fff8'; ctx.strokeRect(a.x, a.y, a.w, a.h); ctx.restore();
    }
  }

  function drawLava(l) {
    ctx.save(); ctx.translate(-camX,0);
    const rimTop = GROUND_Y - LAVA_RIM;
    const pitTop = GROUND_Y;
    const pitBottom = pitTop + LAVA_DEPTH;
    const lavaTop = pitBottom - l.h;

    // grassy rim
    const rimGrad = ctx.createLinearGradient(0, rimTop, 0, pitTop);
    rimGrad.addColorStop(0, '#6fa95c');
    rimGrad.addColorStop(1, '#35592d');
    ctx.fillStyle = rimGrad;
    ctx.fillRect(l.x - 6, rimTop, l.w + 12, LAVA_RIM);

    // pit walls with slight bevel
    const wallGrad = ctx.createLinearGradient(l.x - 6, pitTop, l.x + l.w + 6, pitTop);
    wallGrad.addColorStop(0, '#1c2b16');
    wallGrad.addColorStop(0.08, '#3f5a29');
    wallGrad.addColorStop(0.92, '#3f5a29');
    wallGrad.addColorStop(1, '#1c2b16');
    ctx.fillStyle = wallGrad;
    ctx.fillRect(l.x - 6, pitTop, l.w + 12, LAVA_DEPTH);

    const cavityGrad = ctx.createLinearGradient(0, pitTop, 0, pitBottom);
    cavityGrad.addColorStop(0, '#2f1a11');
    cavityGrad.addColorStop(1, '#0f0502');
    ctx.fillStyle = cavityGrad;
    ctx.fillRect(l.x, pitTop, l.w, LAVA_DEPTH);

    // lava pool
    const lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, pitBottom);
    lavaGrad.addColorStop(0, '#ffb56b');
    lavaGrad.addColorStop(0.45, '#ff6b3a');
    lavaGrad.addColorStop(1, '#d62020');
    ctx.fillStyle = lavaGrad;
    ctx.fillRect(l.x, lavaTop, l.w, pitBottom - lavaTop);

    // animated surface ripple
    ctx.strokeStyle = '#ffd166';
    ctx.lineWidth = 2;
    const t = performance.now()*0.003 + l.phase;
    ctx.beginPath();
    for (let i=0; i<=l.w; i+=4) {
      const y = lavaTop + 4 + Math.sin(t + i*0.2) * 2;
      if (i===0) ctx.moveTo(l.x+i, y); else ctx.lineTo(l.x+i, y);
    }
    ctx.stroke();

    // glow to sell depth
    const glow = ctx.createRadialGradient(l.x + l.w/2, lavaTop + (pitBottom - lavaTop)/2, 0, l.x + l.w/2, lavaTop + (pitBottom - lavaTop)/2, l.w);
    glow.addColorStop(0, '#ff6b3a55');
    glow.addColorStop(1, '#ff6b3a00');
    ctx.fillStyle = glow;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillRect(l.x - 20, lavaTop - 12, l.w + 40, pitBottom - lavaTop + 24);
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();

    if (debugShowHit) {
      const a=l.aabb();
      ctx.save(); ctx.translate(-camX,0); ctx.strokeStyle='#fff8'; ctx.strokeRect(a.x, a.y, a.w, a.h); ctx.restore();
    }
  }

  function drawCoin(c) {
    if (c.collected) return;
    ctx.save(); ctx.translate(-camX,0);
    const bob = Math.sin(c.t*4) * 3;
    ctx.beginPath();
    ctx.arc(c.x, c.y + bob, c.r, 0, Math.PI*2);
    ctx.fillStyle = '#ffd166';
    ctx.fill();
    ctx.strokeStyle = '#c9a44f';
    ctx.lineWidth = 2;
    ctx.stroke();
    // inner shine
    ctx.fillStyle = '#fff8';
    ctx.beginPath();
    ctx.arc(c.x-4, c.y + bob - 4, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawPlayer(player) {
    ctx.save(); ctx.translate(-camX,0);

    // shadow
    ctx.fillStyle = '#0003';
    ctx.beginPath();
    ctx.ellipse(player.centerX(), GROUND_Y-2, 12, 4, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = player.bodyColor;
    ctx.fillRect(player.x, player.y, player.w, player.h);

    // head
    const head = {x: player.x + (player.w-16)/2, y: player.y - 16, s:16};
    ctx.fillStyle = player.headColor;
    ctx.fillRect(head.x, head.y, head.s, head.s);
    // eyes
    ctx.fillStyle = '#1b1b1b';
    ctx.fillRect(head.x+4 + (player.facing>0?2:0), head.y+5, 3, 3);
    ctx.fillRect(head.x+9 + (player.facing>0?2:0), head.y+5, 3, 3);
    // tiny mouth
    ctx.fillRect(head.x+5, head.y+10, 6, 2);

    // direction hint
    if (!player.finished) {
      ctx.fillStyle = '#ffffff33';
      ctx.fillRect(player.centerX() + player.facing*14, player.y+6, 10, 2);
    }

    // hurt flash
    if (player.invuln > 0) {
      ctx.fillStyle = '#ffffff55';
      ctx.fillRect(player.x-2, player.y-18, player.w+4, player.h+20);
    }

    // label
    ctx.fillStyle = '#ffffffdd';
    ctx.font = '600 12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(player.label, player.centerX(), player.y - 20);

    if (debugShowHit) {
      const a=player.aabb();
      ctx.strokeStyle='#fff8'; ctx.strokeRect(a.x, a.y, a.w, a.h);
      ctx.strokeStyle='#0f08'; ctx.strokeRect(head.x, head.y, head.s, head.s);
    }

    ctx.restore();
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    drawGround();

    // parallax trees (background silhouettes)
    ctx.save(); ctx.translate(-camX*0.6,0);
    ctx.fillStyle = '#2f6130';
    for (let i=0;i<18;i++){
      const x = i*220 + 100;
      ctx.fillRect(x+14, GROUND_Y-70, 12, 70);
      ctx.beginPath();
      ctx.roundRect(x, GROUND_Y-110, 40, 30, 10); ctx.fill();
      ctx.beginPath();
      ctx.roundRect(x-6, GROUND_Y-90, 52, 34, 12); ctx.fill();
    }
    ctx.restore();

    // midground: trees, walls, lava, coins, player
    for (const tr of trees) drawTree(tr);
    for (const w of walls) drawWall(w);
    for (const l of lavas) drawLava(l);
    for (const c of coins) drawCoin(c);
    for (const player of players) drawPlayer(player);

    // HUD guide line to goal
    ctx.save();
    ctx.translate(-camX,0);
    ctx.strokeStyle = '#ffffff20';
    ctx.setLineDash([6,6]);
    ctx.beginPath(); ctx.moveTo(GOAL_X, 0); ctx.lineTo(GOAL_X, H); ctx.stroke();
    ctx.restore();
  }

  // ===== polyfills =====
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r) {
      const rr = Math.min(r, w/2, h/2) || 0;
      this.beginPath();
      this.moveTo(x+rr,y);
      this.arcTo(x+w,y,x+w,y+h,rr);
      this.arcTo(x+w,y+h,x,y+h,rr);
      this.arcTo(x,y+h,x,y,rr);
      this.arcTo(x,y,x+w,y,rr);
      this.closePath();
      return this;
    }
  }

  // boot
  resetLevel();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
